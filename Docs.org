#+title: SEED Website Docs

* Front-end
+ [[https://github.com/NasreddinHodja/seed-website][Github]]

[[https://nuxt.com/][Nuxt]] is a front-end framework built on top of [[https://vuejs.org/][Vue.js]]. It provides a structured approach to building web applications with best practices baked in, including performance optimization, SEO, and modular development.

*Pros*:
+ Flexibility: We are starting with Static Site Generation (SSG), but the framework allows for dynamic features in the future (API integration, authentication, etc.)
+ Mental health: Plenty of quality of life for the development experience

*Cons*:
+ none ðŸ”¥ðŸ”¥ðŸ”¥

** Initialize project
=nuxi init= command will prompt you to select a package manager. For our project, we chose [[https://yarnpkg.com/][Yarn]].

#+begin_src sh :caption "init"
# create project
npx nuxi init seed_website

cd seed_website

# install dependencies
yarn install
#+end_src

*** Yarn commands
Changing the =package.json= scripts to use =nuxi=:
#+begin_src json :caption "package.json"
{
  "scripts": {
    "build": "nuxi build",
    "dev": "nuxi dev",
    "lserve": "npx serve .output/public",
    "generate": "nuxi generate",
    "preview": "nuxi preview",
    "postinstall": "nuxi prepare"
  },
}
#+end_src

** Tailwind
For styling, we chose [[https://tailwindcss.com/][tailwindcss]].

Add tailwindcss mobule:
#+begin_src sh :caption "tailwind dependency"
nuxi module add tailwindcss
#+end_src

** Run project locally
#+begin_src sh :caption "run project"
yarn dev
#+end_src

** Generate the static site
Generate using [[https://nuxt.com/docs/api/commands/generate][Static Site Generation (SSG) do Nuxt]]:
#+begin_src sh :caption "generate project"
yarn generate
#+end_src

Serve the generated site locally using:
#+begin_src sh :caption "serve generated project"
yarn lserve
#+end_src

** Project structure
+ =contents/=: Definition of the content of corresponding pages
+ =components/=: Reusable UI components
+ =pages/=: Website pages
+ =layout/=: Layout templates used across multiple pages

** Content isolation
+ Each page is defined by a =.vue= file, which includes its layout, styling, and functionality:
  - Pages live in =pages/=
  - Reusable UI components live in =components/= and are used by pages.
+ Each page has its content (titles, descriptions, URLs for media, etc.) defined inside =.ts= files in =content/=

The structure of the =pages/= directory determines the URL paths, and the =content/= directory mirrors this structure.

*For every =.vue= file in =pages/= there is a corresponding =.ts= file in =content/= that holds its contents*

*** Content files
!!! TODO !!!

* Content change guide
(Read [[* Content Isolation][Content Isolation]] before)

** Git
Git is like a time machine for your project.

It keeps track of every change you (or anyone) make to the website's files.

With Git you can:
+ Go back to previous versions if something breaks
+ See who changed what and when
+ Work together without overwriting each other's work

*** Commits
Git doesnâ€™t automatically track every little change you make.
You have to tell it when youâ€™re ready to save a snapshot.

This is called a *commit* - itâ€™s like saying: "alright, git, I think I'm done with this bundle of changes..."

*When you commit, youâ€™re officially recording the changes you made to the project.*

Examples:
+ Fixing a bug:
  - If itâ€™s a small fix, Iâ€™ll just solve it and make one commit at the end.
  - But if it involves multiple steps, I might commit after each meaningful step - so I can go back if something breaks.
+ Changing a page title:
  - Iâ€™ll open the corresponding file in =content/=, update the title, and then make a commit with a message like: "fixed title for page X".

*** Branches
Our project lives on a branch called =main= â€” like the main road where everything eventually ends up.

A *branch* is a separate path where you can work on something new without messing up the main version.

Branches can:
+ Be created from other branches
  - For example, we usually create new branches from =dev= when we want to work on a specific task.
+ Be *merged* into other branches
  - This is how we update a branch with new changes from another.
  - For example, when a new feature/fix is ready, we merge its branch back into =dev= to include the new work.

**** Branches in our project
We use branches to keep things organized and safe.

These are the main ones we'll work with:
+ =main= - The official branch
  - This is the version that gets published to the actual website.
  - Only the project owner can make changes here.
  - Think of it as the live, stable version.
+ =dev= - The development branch
  - This is where we work on new features and fixes.
  - Whenever we want to fix something or add something new, we create a new branch from =dev=.
  - After we finish and commit the changes, we merge that branch back into =dev=.

Examples:
+ Adding a new page:
  - I'll create a branch called =new-about-page=, build the page there, and when it's ready, I'll merge it into the main branch.
+ Making experimental changes: (I want to test or prototype light/dark modes for the website)
  - I might create a branch like =dark-mode-test=, so I can experiment without affecting whatâ€™s already working.

Over time, =dev= will have new changes that =main= doesnâ€™t know about yet - =dev= is "*ahead*" of =main=.

When it's time to publish those changes to the website, the project owner will merge =dev= into =main=.

**** Naming branches
When you create a new branch, it's important to give it a name that clearly describes what you're working on.
This helps everyone understand what the branch is for - without needing to open it.

*Use short, clear, lowercase names with '-' to separate words.*

Examples:
+ =fix-typo-on-homepage= - fixing a small text error
+ =add-contact-form= - adding a new feature
+ =update-footer-links= - making content changes
+ =issue-23-fix-login-bug= - referencing a task or GitHub issue


** GitHub
GitHub is an online platform that hosts our Git project, so we can work together and share updates.

It also gives us tools like:
+ *Pull requests* â€” to review and discuss changes before they go in
+ Issue tracking â€” to assign and follow tasks
+ Online backups of the entire project

Youâ€™ll use GitHub to *push* your changes to the team, and *pull* new updates when someone else makes changes.

Once your project is hosted on GitHub, it lives in two places:
+ *Local* - the version on your computer (what you open and edit)
+ *Remote* - the version on GitHub (what the team sees and works with online)

*You make changes locally, and then use GitHub Desktop to push those changes to the remote.*

*If someone else makes changes, you pull from the remote to update your local copy.*

Think of it like working on a shared Google Doc â€” except each person has their own offline copy, and you sync with GitHub to stay up to date.

*** Pull requets
A *pull request* (PR) is a request to merge a branch to another.
It is a safety step so that people can review the changes before updating important branches.

- It's a safety step - instead of merging directly, you ask for the changes to be reviewed first
- This helps catch mistakes and makes sure everything looks good before updating important branches like =dev= or =main=
- On GitHub, youâ€™ll create a pull request when youâ€™re done with your work and ready to bring your branch back into =dev=

** GitHub Desktop
GitHub Desktop is a visual app that makes using Git easy - no terminal needed.

*It's is a GUI client for Git.*

With it, you can:
+ Open the project
+ See which files youâ€™ve changed
+ Write a commit message
+ Push your changes to GitHub
+ Pull new updates from others

** Making a change to the project
1. *Pull from remote*:
  - Make sure your local project is up to date with the latest changes
2. *Create a branch*:
  - Create a branch from =dev= and give it a clear, descriptive name based on what you're working on.
3. *Make your changes*:
  - Edit the files you need â€” usually in the content/ folder for text and content updates.
4. *Commit your changes*
  - Once the issue seems solved, commit with a short, clear message explaining what you did.
5. *Push to remote*
  - Send your branch (and commits) to GitHub. This will create the branch on the remote project.
6. *Open a pull request*
  - On GitHub, create a pull request from your branch into dev, so others can review and merge your work.

* Back-end
** Cloudflare R2 Object Storage
We will be using [[https://www.cloudflare.com/][Cloudflare]] to store public media and documents.

*** Cloudflare Worker
+ [[https://github.com/NasreddinHodja/seed-r2-worker][Github]]

Little friend that will be serving our files through public URL.

We will use: =https://seed-r2-worker.seedworker.workers.dev/<BUCKET_NAME>/<FILE_NAME>=

**** Init
#+begin_src sh :caption "init"
npm create cloudflare@latest -- seed-r2-worker
cd seed-r2-worker
#+end_src

For setup, select the following options:
1. For "What would you like to start with?", choose "Hello World example".
2. For "Which template would you like to use?", choose "Worker only".
3. For "Which language do you want to use?", choose "JavaScript".
4. For "Do you want to use git for version control?", choose "Yes".
5. For "Do you want to deploy your application?", choose "No (we will be making some changes before deploying)".

**** Create bucket
#+begin_src sh :caption "create bucket"
npx wrangler r2 bucket create <YOUR_BUCKET_NAME>
#+end_src

**** Bind bucket to worker
#+begin_src sh :caption "wrangler.jsonc"
{
  "r2_buckets": [
    {
      "binding": "MY_BUCKET",
      "bucket_name": "<YOUR_BUCKET_NAME>"
    }
  ]
}
#+end_src

**** Simple worker
#+begin_src javascript :caption "worker"
export default {
    async fetch(request, env) {
        const url = new URL(request.url);
        const key = url.pathname.slice(1);

        switch (request.method) {
            // case 'PUT':
            //          await env.MY_BUCKET.put(key, request.body);
            //          return new Response(`Put ${key} successfully!`);
            case 'GET':
                const object = await env.MY_BUCKET.get(key);

                if (object === null) {
                    return new Response('Object Not Found', { status: 404 });
                }

                const headers = new Headers();
                object.writeHttpMetadata(headers);
                headers.set('etag', object.httpEtag);

                return new Response(object.body, {
                    headers,
                });
            // case 'DELETE':
            //          await env.MY_BUCKET.delete(key);
            //          return new Response('Deleted!');

            default:
                return new Response('Method Not Allowed', {
                    status: 405,
                    headers: {
                        Allow: 'GET',
                    },
                });
        }
    },
};
#+end_src

We can test locally with:
#+begin_src sh :caption "test locally"
npx wrangler dev
#+end_src

And deploy:
#+begin_src sh :caption "deploy worker"
npx wrangler deploy
#+end_src
